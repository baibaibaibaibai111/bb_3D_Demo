<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8" />
  <title>模拟人生 · 建造系统原型</title>
  <style>
    body {
      margin: 0;
      overflow: hidden;
      background: #111;
    }
    #tip {
      position: fixed;
      left: 10px;
      top: 10px;
      color: #fff;
      font-size: 14px;
      opacity: 0.8;
    }
    #toolbar {
      position: fixed;
      left: 10px;
      top: 60px;
      color: #fff;
      font-size: 14px;
    }
    #toolbar .row {
      margin-bottom: 4px;
    }
    #toolbar button {
      margin-right: 4px;
      padding: 2px 6px;
      font-size: 12px;
      cursor: pointer;
      border-radius: 3px;
      border: 1px solid #555;
      background: #222;
      color: #fff;
    }
    #toolbar button.active {
      background: #4caf50;
      border-color: #4caf50;
    }
  </style>
</head>
<body>

<div id="tip">
  左键拖拽：铺地板 ｜ 右键：删除地板<br/>
  墙体模式：按下左键从 A 点拖到 B 点，松开生成墙
</div>

<div id="toolbar">
  <div class="row">
    <button class="game-mode-button" data-game-mode="build">建造模式</button>
    <button class="game-mode-button" data-game-mode="live">生活模式</button>
  </div>
  <div class="row">
    <button class="mode-button" data-mode="floor">地板</button>
    <button class="mode-button" data-mode="wall">墙体</button>
    <button class="mode-button" data-mode="furniture">家具</button>
  </div>
  <div class="row">
    <button id="saveLayout">保存布局</button>
    <button id="loadLayout">加载布局</button>
  </div>
  <div class="row" id="furniturePanel">
    家具：
    <button class="furniture-type-button" data-type="bed">床</button>
    <button class="furniture-type-button" data-type="sofa">沙发</button>
    <button class="furniture-type-button" data-type="table">桌子</button>
    <button id="rotateFurnitureBtn">旋转选中家具</button>
  </div>
</div>

<script type="importmap">
{
  "imports": {
    "three": "https://unpkg.com/three@0.158.0/build/three.module.js",
    "three/examples/": "https://unpkg.com/three@0.158.0/examples/jsm/"
  }
}
</script>

<script type="module">
import * as THREE from "three";
import { OrbitControls } from "three/examples/controls/OrbitControls.js";

/* ================= 基础 ================= */

const scene = new THREE.Scene();
scene.background = new THREE.Color(0x202020);

const camera = new THREE.PerspectiveCamera(60, innerWidth / innerHeight, 0.1, 1000);
camera.position.set(8, 8, 8);

const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setSize(innerWidth, innerHeight);
renderer.shadowMap.enabled = true;
document.body.appendChild(renderer.domElement);

const controls = new OrbitControls(camera, renderer.domElement);
controls.enableDamping = true;
const clock = new THREE.Clock();

/* ================= 灯光 ================= */

scene.add(new THREE.AmbientLight(0xffffff, 0.45));

const dirLight = new THREE.DirectionalLight(0xffffff, 0.9);
dirLight.position.set(10, 15, 8);
dirLight.castShadow = true;
scene.add(dirLight);

/* ================= 地面 ================= */

const ground = new THREE.Mesh(
  new THREE.PlaneGeometry(50, 50),
  new THREE.MeshStandardMaterial({ color: 0x3a3a3a, roughness: 1 })
);
ground.rotation.x = -Math.PI / 2;
ground.receiveShadow = true;
scene.add(ground);

const grid = new THREE.GridHelper(50, 50, 0x444444, 0x444444);
grid.position.y = 0.001;
scene.add(grid);

/* ================= 工具 ================= */

const raycaster = new THREE.Raycaster();
const mouse = new THREE.Vector2();
const snap = v => Math.floor(v);

/* ================= 数据 ================= */

const floors = [];
const walls = [];
const furnitures = [];

let gameMode = "build"; // build | live
let buildMode = "floor"; // floor | wall | furniture
let wallStart = null;
let currentFurnitureType = "bed";
let selectedFurniture = null;
let lastWallGrid = null;
let wallPreview = null;
let draggingFurniture = false;
let draggedFurniture = null;
let character = null;
let moveForward = false;
let moveBackward = false;
let moveLeft = false;
let moveRight = false;

let moveTarget = null; // THREE.Vector3 | null
let hasMoveTarget = false;
let moveMarker = null;
let pathCells = null;
let pathIndex = 0;
let walkPhase = 0;

/* ================= 地板 ================= */

function createFloor(x, z) {
  for (let i = 0; i < floors.length; i++) {
    const g = floors[i].userData && floors[i].userData.grid;
    if (g && g.x === x && g.z === z) {
      return;
    }
  }
  const floor = new THREE.Mesh(
    new THREE.BoxGeometry(1, 0.1, 1),
    new THREE.MeshStandardMaterial({ color: 0x999999 })
  );
  floor.position.set(x + 0.5, 0.05, z + 0.5);
  floor.receiveShadow = true;
  floor.userData.grid = { x, z };
  scene.add(floor);
  floors.push(floor);
}

/* ================= 墙体 ================= */

function createWall(x, z, dir) {
  const height = 2.5;
  const thickness = 0.1;

  for (let i = 0; i < walls.length; i++) {
    const d = walls[i].userData;
    if (d && d.x === x && d.z === z && d.dir === dir) {
      return;
    }
  }

  const geo =
    dir === "x"
      ? new THREE.BoxGeometry(1, height, thickness)
      : new THREE.BoxGeometry(thickness, height, 1);

  const wall = new THREE.Mesh(
    geo,
    new THREE.MeshStandardMaterial({ color: 0xf2f2f2 })
  );

  wall.position.set(
    dir === "x" ? x + 0.5 : x,
    height / 2,
    dir === "z" ? z + 0.5 : z
  );

  wall.castShadow = true;
  wall.receiveShadow = true;
  wall.userData = { x, z, dir };

  scene.add(wall);
  walls.push(wall);
}

function createFurniture(x, z, type = currentFurnitureType, rotationY = 0) {
  for (let i = 0; i < furnitures.length; i++) {
    const g = furnitures[i].userData && furnitures[i].userData.grid;
    if (g && g.x === x && g.z === z) {
      return;
    }
  }

  let mainColor = 0x8bc34a;
  if (type === "bed") mainColor = 0x03a9f4;
  else if (type === "sofa") mainColor = 0x9c27b0;
  else if (type === "table") mainColor = 0xffc107;

  const group = new THREE.Group();
  let highlightTarget = null;

  if (type === "bed") {
    const baseGeo = new THREE.BoxGeometry(0.9, 0.3, 1.6);
    const headGeo = new THREE.BoxGeometry(0.9, 0.5, 0.2);
    const baseMat = new THREE.MeshStandardMaterial({ color: mainColor });
    const headMat = new THREE.MeshStandardMaterial({ color: 0x01579b });

    const base = new THREE.Mesh(baseGeo, baseMat);
    base.position.set(0, 0.25, 0);
    base.castShadow = true;
    base.receiveShadow = true;

    const head = new THREE.Mesh(headGeo, headMat);
    head.position.set(0, 0.45, -0.7);
    head.castShadow = true;
    head.receiveShadow = true;

    group.add(base);
    group.add(head);
    highlightTarget = base;
  } else if (type === "sofa") {
    const seatGeo = new THREE.BoxGeometry(1.1, 0.3, 0.7);
    const backGeo = new THREE.BoxGeometry(1.1, 0.5, 0.2);
    const armGeo = new THREE.BoxGeometry(0.2, 0.4, 0.7);
    const seatMat = new THREE.MeshStandardMaterial({ color: mainColor });
    const backMat = new THREE.MeshStandardMaterial({ color: 0x6a1b9a });
    const armMat = new THREE.MeshStandardMaterial({ color: 0x4a148c });

    const seat = new THREE.Mesh(seatGeo, seatMat);
    seat.position.set(0, 0.25, 0);
    seat.castShadow = true;
    seat.receiveShadow = true;

    const back = new THREE.Mesh(backGeo, backMat);
    back.position.set(0, 0.55, -0.25);
    back.castShadow = true;
    back.receiveShadow = true;

    const armL = new THREE.Mesh(armGeo, armMat);
    armL.position.set(-0.55, 0.45, 0);
    armL.castShadow = true;
    armL.receiveShadow = true;

    const armR = new THREE.Mesh(armGeo, armMat);
    armR.position.set(0.55, 0.45, 0);
    armR.castShadow = true;
    armR.receiveShadow = true;

    group.add(seat, back, armL, armR);
    highlightTarget = seat;
  } else if (type === "table") {
    const topGeo = new THREE.BoxGeometry(1.0, 0.1, 1.0);
    const legGeo = new THREE.BoxGeometry(0.1, 0.6, 0.1);
    const topMat = new THREE.MeshStandardMaterial({ color: mainColor });
    const legMat = new THREE.MeshStandardMaterial({ color: 0x795548 });

    const top = new THREE.Mesh(topGeo, topMat);
    top.position.set(0, 0.65, 0);
    top.castShadow = true;
    top.receiveShadow = true;

    const legOffsets = [
      [-0.45, 0.35, -0.45],
      [0.45, 0.35, -0.45],
      [-0.45, 0.35, 0.45],
      [0.45, 0.35, 0.45]
    ];

    group.add(top);
    legOffsets.forEach(([lx, ly, lz]) => {
      const leg = new THREE.Mesh(legGeo, legMat);
      leg.position.set(lx, ly, lz);
      leg.castShadow = true;
      leg.receiveShadow = true;
      group.add(leg);
    });

    highlightTarget = top;
  } else {
    const geo = new THREE.BoxGeometry(0.8, 0.8, 0.8);
    const mat = new THREE.MeshStandardMaterial({ color: mainColor });
    const box = new THREE.Mesh(geo, mat);
    box.position.set(0, 0.4, 0);
    box.castShadow = true;
    box.receiveShadow = true;
    group.add(box);
    highlightTarget = box;
  }

  group.position.set(x + 0.5, 0, z + 0.5);
  group.rotation.y = rotationY;
  group.castShadow = true;
  group.receiveShadow = true;
  group.userData = {
    grid: { x, z },
    type,
    rotationY,
    highlightTarget
  };

  scene.add(group);
  furnitures.push(group);
  setSelectedFurniture(group);
  return group;
}

function isCellWalkable(x, z) {
  let hasFloor = false;
  for (let i = 0; i < floors.length; i++) {
    const g = floors[i].userData && floors[i].userData.grid;
    if (g && g.x === x && g.z === z) {
      hasFloor = true;
      break;
    }
  }
  if (!hasFloor) return false;

  for (let i = 0; i < furnitures.length; i++) {
    const g = furnitures[i].userData && furnitures[i].userData.grid;
    if (g && g.x === x && g.z === z) {
      return false;
    }
  }

  return true;
}

function hasWallBetweenCells(x1, z1, x2, z2) {
  const dx = x2 - x1;
  const dz = z2 - z1;
  if (Math.abs(dx) + Math.abs(dz) !== 1) return false;

  if (dz === 1) {
    const wx = x1;
    const wz = z1 + 1;
    for (let i = 0; i < walls.length; i++) {
      const d = walls[i].userData;
      if (d && d.dir === "x" && d.x === wx && d.z === wz) return true;
    }
  } else if (dz === -1) {
    const wx = x1;
    const wz = z1;
    for (let i = 0; i < walls.length; i++) {
      const d = walls[i].userData;
      if (d && d.dir === "x" && d.x === wx && d.z === wz) return true;
    }
  } else if (dx === 1) {
    const wx = x1 + 1;
    const wz = z1;
    for (let i = 0; i < walls.length; i++) {
      const d = walls[i].userData;
      if (d && d.dir === "z" && d.x === wx && d.z === wz) return true;
    }
  } else if (dx === -1) {
    const wx = x1;
    const wz = z1;
    for (let i = 0; i < walls.length; i++) {
      const d = walls[i].userData;
      if (d && d.dir === "z" && d.x === wx && d.z === wz) return true;
    }
  }

  return false;
}

function canMoveCharacterTo(fromX, fromZ, toX, toZ) {
  const cx = Math.floor(fromX);
  const cz = Math.floor(fromZ);
  const nx = Math.floor(toX);
  const nz = Math.floor(toZ);

  if (nx === cx && nz === cz) {
    return true;
  }

  if (!isCellWalkable(nx, nz)) return false;
  if (hasWallBetweenCells(cx, cz, nx, nz)) return false;

  return true;
}

function updateCharacterRotationTowards(dirX, dirZ, delta) {
  if (!character) return;
  const len = Math.hypot(dirX, dirZ) || 1;
  const ndx = dirX / len;
  const ndz = dirZ / len;
  const targetAngle = Math.atan2(ndx, ndz);

  let current = character.rotation.y;
  let diff = targetAngle - current;
  diff = ((diff + Math.PI) % (Math.PI * 2)) - Math.PI;

  const turnSpeed = 8; // rad/s
  const maxStep = turnSpeed * delta;
  if (Math.abs(diff) <= maxStep) {
    current = targetAngle;
  } else {
    current += Math.sign(diff) * maxStep;
  }
  character.rotation.y = current;
}

function findPath(startX, startZ, targetX, targetZ) {
  if (!isCellWalkable(targetX, targetZ)) return null;

  let minX = Infinity;
  let maxX = -Infinity;
  let minZ = Infinity;
  let maxZ = -Infinity;

  floors.forEach(f => {
    const g = f.userData && f.userData.grid;
    if (!g) return;
    if (g.x < minX) minX = g.x;
    if (g.x > maxX) maxX = g.x;
    if (g.z < minZ) minZ = g.z;
    if (g.z > maxZ) maxZ = g.z;
  });

  if (!isFinite(minX)) {
    return null;
  }

  minX -= 1;
  maxX += 1;
  minZ -= 1;
  maxZ += 1;

  const key = (x, z) => `${x},${z}`;
  const queue = [];
  const visited = new Set();
  const cameFrom = Object.create(null);

  const startKey = key(startX, startZ);
  queue.push({ x: startX, z: startZ });
  visited.add(startKey);
  cameFrom[startKey] = null;

  const dirs = [
    [1, 0],
    [-1, 0],
    [0, 1],
    [0, -1]
  ];

  let foundKey = null;

  while (queue.length) {
    const node = queue.shift();
    if (node.x === targetX && node.z === targetZ) {
      foundKey = key(node.x, node.z);
      break;
    }

    for (let i = 0; i < dirs.length; i++) {
      const dx = dirs[i][0];
      const dz = dirs[i][1];
      const nx = node.x + dx;
      const nz = node.z + dz;

      if (nx < minX || nx > maxX || nz < minZ || nz > maxZ) continue;
      const nk = key(nx, nz);
      if (visited.has(nk)) continue;
      if (!isCellWalkable(nx, nz)) continue;
      if (hasWallBetweenCells(node.x, node.z, nx, nz)) continue;

      visited.add(nk);
      cameFrom[nk] = key(node.x, node.z);
      queue.push({ x: nx, z: nz });
    }
  }

  if (!foundKey) return null;

  const path = [];
  let currentKey = foundKey;
  while (currentKey) {
    const parts = currentKey.split(",");
    const x = parseInt(parts[0], 10);
    const z = parseInt(parts[1], 10);
    path.push({ x, z });
    currentKey = cameFrom[currentKey];
  }

  path.reverse();
  return path;
}

function ensureCharacter() {
  if (character) return character;

  const group = new THREE.Group();

  // 簡單人形：頭、軀幹、骨盆、手臂和雙腿
  const skinColor = 0xffe0bd;
  const shirtColor = 0x2196f3;
  const pantsColor = 0x455a64;
  const shoeColor = 0x212121;

  // 軀幹
  const torsoGeo = new THREE.BoxGeometry(0.45, 0.6, 0.25);
  const torsoMat = new THREE.MeshStandardMaterial({ color: shirtColor });
  const torso = new THREE.Mesh(torsoGeo, torsoMat);
  torso.position.set(0, 0.95, 0);
  torso.castShadow = true;
  torso.receiveShadow = true;

  // 骨盆 / 腰
  const pelvisGeo = new THREE.BoxGeometry(0.35, 0.25, 0.22);
  const pelvisMat = new THREE.MeshStandardMaterial({ color: pantsColor });
  const pelvis = new THREE.Mesh(pelvisGeo, pelvisMat);
  pelvis.position.set(0, 0.7, 0);
  pelvis.castShadow = true;
  pelvis.receiveShadow = true;

  // 頭
  const headGeo = new THREE.SphereGeometry(0.22, 18, 18);
  const headMat = new THREE.MeshStandardMaterial({ color: skinColor });
  const head = new THREE.Mesh(headGeo, headMat);
  head.position.set(0, 1.45, 0.02);
  head.castShadow = true;
  head.receiveShadow = true;

  // 手臂
  const armGeo = new THREE.BoxGeometry(0.12, 0.55, 0.18);
  const armMat = new THREE.MeshStandardMaterial({ color: shirtColor });
  const armOffsetX = 0.45 / 2 + 0.12 / 2 + 0.02;
  const armY = 0.98;

  const leftArm = new THREE.Mesh(armGeo, armMat);
  leftArm.position.set(-armOffsetX, armY, 0);
  leftArm.castShadow = true;
  leftArm.receiveShadow = true;

  const rightArm = new THREE.Mesh(armGeo, armMat);
  rightArm.position.set(armOffsetX, armY, 0);
  rightArm.castShadow = true;
  rightArm.receiveShadow = true;

  // 腿
  const legGeo = new THREE.BoxGeometry(0.16, 0.75, 0.2);
  const legMat = new THREE.MeshStandardMaterial({ color: pantsColor });
  const legOffsetX = 0.18;
  const legY = 0.375;

  const leftLeg = new THREE.Mesh(legGeo, legMat);
  leftLeg.position.set(-legOffsetX, legY, 0);
  leftLeg.castShadow = true;
  leftLeg.receiveShadow = true;

  const rightLeg = new THREE.Mesh(legGeo, legMat);
  rightLeg.position.set(legOffsetX, legY, 0);
  rightLeg.castShadow = true;
  rightLeg.receiveShadow = true;

  // 腳
  const footGeo = new THREE.BoxGeometry(0.18, 0.08, 0.3);
  const footMat = new THREE.MeshStandardMaterial({ color: shoeColor });
  const footY = 0.04;

  const leftFoot = new THREE.Mesh(footGeo, footMat);
  leftFoot.position.set(-legOffsetX, footY, 0.05);
  leftFoot.castShadow = true;
  leftFoot.receiveShadow = true;

  const rightFoot = new THREE.Mesh(footGeo, footMat);
  rightFoot.position.set(legOffsetX, footY, 0.05);
  rightFoot.castShadow = true;
  rightFoot.receiveShadow = true;

  group.add(torso);
  group.add(pelvis);
  group.add(head);
  group.add(leftArm);
  group.add(rightArm);
  group.add(leftLeg);
  group.add(rightLeg);
  group.add(leftFoot);
  group.add(rightFoot);

  let spawnX = 0.5;
  let spawnZ = 0.5;
  if (floors.length > 0) {
    const g = floors[0].userData && floors[0].userData.grid;
    if (g) {
      spawnX = g.x + 0.5;
      spawnZ = g.z + 0.5;
    }
  }

  group.position.set(spawnX, 0, spawnZ);
  group.castShadow = true;
  group.receiveShadow = true;

  group.userData = {
    body: torso,
    head,
    baseBodyY: torso.position.y,
    baseHeadY: head.position.y,
    leftArm,
    rightArm,
    leftLeg,
    rightLeg
  };

  scene.add(group);
  character = group;
  return character;
}

function getFurnitureRoot(target) {
  if (!target) return null;
  let current = target;
  while (current) {
    if (furnitures.includes(current)) return current;
    current = current.parent;
  }
  return null;
}

function setSelectedFurniture(obj) {
  const root = getFurnitureRoot(obj) || obj || null;

  const getHighlight = target => {
    if (!target) return null;
    const rootObj = getFurnitureRoot(target) || target;
    if (rootObj.userData && rootObj.userData.highlightTarget) {
      return rootObj.userData.highlightTarget;
    }
    return rootObj;
  };

  const prev = getHighlight(selectedFurniture);
  if (prev && prev.material && prev.material.emissive) {
    prev.material.emissive.setHex(0x000000);
  }

  selectedFurniture = root;

  const cur = getHighlight(selectedFurniture);
  if (cur && cur.material && cur.material.emissive) {
    cur.material.emissive.setHex(0x444444);
  }
}

function clearWallPreview() {
  if (wallPreview) {
    scene.remove(wallPreview);
    if (wallPreview.geometry) wallPreview.geometry.dispose();
    if (wallPreview.material) wallPreview.material.dispose();
    wallPreview = null;
  }
}

function updateWallPreview(start, end) {
  if (!start || !end) {
    clearWallPreview();
    return;
  }

  const dx = end.x - start.x;
  const dz = end.z - start.z;
  if (dx === 0 && dz === 0) {
    clearWallPreview();
    return;
  }

  let x1 = start.x;
  let z1 = start.z;
  let x2 = end.x;
  let z2 = end.z;

  if (Math.abs(dx) >= Math.abs(dz)) {
    z2 = z1;
  } else {
    x2 = x1;
  }

  const height = 2.5;
  const y = height;
  const p1 = new THREE.Vector3(x1, y, z1);
  const p2 = new THREE.Vector3(x2, y, z2);

  const geometry = new THREE.BufferGeometry().setFromPoints([p1, p2]);
  const material = new THREE.LineDashedMaterial({
    color: 0xffff00,
    dashSize: 0.4,
    gapSize: 0.2
  });

  const line = new THREE.Line(geometry, material);
  line.computeLineDistances();

  clearWallPreview();
  wallPreview = line;
  scene.add(wallPreview);
}

/* ================= 交互 ================= */

const modeButtons = Array.from(document.querySelectorAll(".mode-button"));
const saveBtn = document.getElementById("saveLayout");
const loadBtn = document.getElementById("loadLayout");
const furnitureTypeButtons = Array.from(document.querySelectorAll(".furniture-type-button"));
const rotateFurnitureBtn = document.getElementById("rotateFurnitureBtn");
const gameModeButtons = Array.from(document.querySelectorAll(".game-mode-button"));

function setGameMode(mode) {
  if (gameMode === mode) return;
  gameMode = mode;

  gameModeButtons.forEach(btn => {
    btn.classList.toggle("active", btn.dataset.gameMode === gameMode);
  });

  if (gameMode === "live") {
    draggingFloor = false;
    draggingWall = false;
    draggingFurniture = false;
    draggedFurniture = null;
    clearWallPreview();
    controls.enabled = true;
    ensureCharacter();
  } else {
    moveForward = false;
    moveBackward = false;
    moveLeft = false;
    moveRight = false;
    hasMoveTarget = false;
    pathCells = null;
    pathIndex = 0;
    if (moveMarker) moveMarker.visible = false;
  }
}

function setBuildMode(mode) {
  buildMode = mode;
  if (buildMode === "wall") {
    wallStart = null;
    lastWallGrid = null;
  } else {
    clearWallPreview();
  }
  modeButtons.forEach(btn => {
    btn.classList.toggle("active", btn.dataset.mode === buildMode);
  });
}

function setCurrentFurnitureType(type) {
  currentFurnitureType = type;
  furnitureTypeButtons.forEach(btn => {
    btn.classList.toggle("active", btn.dataset.type === currentFurnitureType);
  });
}

setBuildMode(buildMode);
setCurrentFurnitureType(currentFurnitureType);

if (gameModeButtons.length) {
  setGameMode(gameMode);
  gameModeButtons.forEach(btn => {
    btn.addEventListener("click", () => {
      setGameMode(btn.dataset.gameMode);
    });
  });
}

modeButtons.forEach(btn => {
  btn.addEventListener("click", () => {
    setGameMode("build");
    setBuildMode(btn.dataset.mode);
  });
});

furnitureTypeButtons.forEach(btn => {
  btn.addEventListener("click", () => {
    setCurrentFurnitureType(btn.dataset.type);
  });
});

if (saveBtn) {
  saveBtn.addEventListener("click", () => {
    exportLayout();
  });
}

if (loadBtn) {
  loadBtn.addEventListener("click", () => {
    importLayout();
  });
}

if (rotateFurnitureBtn) {
  rotateFurnitureBtn.addEventListener("click", () => {
    rotateSelectedFurniture();
  });
}

function rotateSelectedFurniture() {
  if (!selectedFurniture) return;
  selectedFurniture.rotation.y =
    (selectedFurniture.rotation.y + Math.PI / 2) % (Math.PI * 2);
  if (!selectedFurniture.userData) {
    selectedFurniture.userData = {};
  }
  if (!selectedFurniture.userData.grid) {
    selectedFurniture.userData.grid = {
      x: Math.floor(selectedFurniture.position.x),
      z: Math.floor(selectedFurniture.position.z)
    };
  }
  selectedFurniture.userData.rotationY = selectedFurniture.rotation.y;
}

window.addEventListener("keydown", e => {
  if (gameMode === "build") {
    if (e.key === "1") {
      setBuildMode("floor");
      console.log("切换为：地板模式");
    }
    if (e.key === "2") {
      setBuildMode("wall");
      console.log("切换为：墙体模式");
    }
    if (e.key === "3") {
      setBuildMode("furniture");
      console.log("切换为：家具模式");
    }
    // 單獨按 R 旋轉家具，避免 Ctrl+R 等快捷鍵干擾
    if (
      (e.code === "KeyR" || e.key === "r" || e.key === "R") &&
      !e.ctrlKey &&
      !e.metaKey &&
      buildMode === "furniture" &&
      selectedFurniture
    ) {
      e.preventDefault();
      rotateSelectedFurniture();
    }
  }

  if (gameMode === "live") {
    if (e.key === "w" || e.key === "W" || e.key === "ArrowUp") {
      moveForward = true;
    }
    if (e.key === "s" || e.key === "S" || e.key === "ArrowDown") {
      moveBackward = true;
    }
    if (e.key === "a" || e.key === "A" || e.key === "ArrowLeft") {
      moveLeft = true;
    }
    if (e.key === "d" || e.key === "D" || e.key === "ArrowRight") {
      moveRight = true;
    }
  }
});

window.addEventListener("mousedown", e => {
  if (gameMode !== "live" || e.button !== 0) return;
  updateMouse(e);
  raycaster.setFromCamera(mouse, camera);

  const hit = raycaster.intersectObject(ground);
  if (!hit.length) return;

  ensureCharacter();
  const targetCellX = snap(hit[0].point.x);
  const targetCellZ = snap(hit[0].point.z);

  const startCellX = Math.floor(character.position.x);
  const startCellZ = Math.floor(character.position.z);

  const path = findPath(startCellX, startCellZ, targetCellX, targetCellZ);
  if (!path || path.length < 2) {
    hasMoveTarget = false;
    if (moveMarker) moveMarker.visible = false;
    return;
  }

  pathCells = path;
  pathIndex = 1; // 0 是當前所在格子
  moveTarget = new THREE.Vector3(targetCellX + 0.5, 0, targetCellZ + 0.5);
  hasMoveTarget = true;

  if (!moveMarker) {
    const geo = new THREE.CircleGeometry(0.3, 16);
    const mat = new THREE.MeshBasicMaterial({ color: 0xffff00, transparent: true, opacity: 0.7 });
    moveMarker = new THREE.Mesh(geo, mat);
    moveMarker.rotation.x = -Math.PI / 2;
    moveMarker.position.y = 0.01;
    scene.add(moveMarker);
  }
  moveMarker.position.x = moveTarget.x;
  moveMarker.position.z = moveTarget.z;
  moveMarker.visible = true;
});

window.addEventListener("keyup", e => {
  if (gameMode !== "live") return;

  if (e.key === "w" || e.key === "W" || e.key === "ArrowUp") {
    moveForward = false;
  }
  if (e.key === "s" || e.key === "S" || e.key === "ArrowDown") {
    moveBackward = false;
  }
  if (e.key === "a" || e.key === "A" || e.key === "ArrowLeft") {
    moveLeft = false;
  }
  if (e.key === "d" || e.key === "D" || e.key === "ArrowRight") {
    moveRight = false;
  }
});

function updateMouse(e) {
  mouse.x = (e.clientX / innerWidth) * 2 - 1;
  mouse.y = -(e.clientY / innerHeight) * 2 + 1;
}

window.addEventListener("contextmenu", e => e.preventDefault());

let draggingFloor = false;
let draggingWall = false;

window.addEventListener("mousedown", e => {
  if (gameMode !== "build") return;
  updateMouse(e);
  raycaster.setFromCamera(mouse, camera);

  const hit = raycaster.intersectObject(ground);
  if (!hit.length) return;

  const x = snap(hit[0].point.x);
  const z = snap(hit[0].point.z);

  // 左键
  if (e.button === 0) {
    if (buildMode === "floor") {
      draggingFloor = true;
      controls.enabled = false;
      createFloor(x, z);
    }

    if (buildMode === "wall") {
      draggingWall = true;
      controls.enabled = false;
      wallStart = { x, z };
      lastWallGrid = { x, z };
    }

    if (buildMode === "furniture") {
      const hitFurniture = raycaster.intersectObjects(furnitures, true);
      if (hitFurniture.length) {
        const root = getFurnitureRoot(hitFurniture[0].object) || hitFurniture[0].object;
        setSelectedFurniture(root);
        draggingFurniture = true;
        draggedFurniture = root;
        controls.enabled = false;
      } else {
        const created = createFurniture(x, z);
        if (created) {
          draggingFurniture = true;
          draggedFurniture = created;
          controls.enabled = false;
        }
      }
    }
  }

  // 右键删除地板
  if (e.button === 2) {
    const hitFurniture = raycaster.intersectObjects(furnitures, true);
    if (hitFurniture.length) {
      const obj = hitFurniture[0].object;
      const root = getFurnitureRoot(obj) || obj;
      scene.remove(root);
      const idxF = furnitures.indexOf(root);
      if (idxF !== -1) {
        furnitures.splice(idxF, 1);
      }
      if (selectedFurniture === root) {
        setSelectedFurniture(null);
      }
      return;
    }

    const hitFloor = raycaster.intersectObjects(floors);
    if (!hitFloor.length) return;

    const f = hitFloor[0].object;
    scene.remove(f);
    const idx = floors.indexOf(f);
    if (idx !== -1) {
      floors.splice(idx, 1);
    }
  }
});

window.addEventListener("mousemove", e => {
  if (!draggingFloor && !draggingWall && !draggingFurniture) return;
  updateMouse(e);
  raycaster.setFromCamera(mouse, camera);

  const hit = raycaster.intersectObject(ground);
  if (!hit.length) return;

  const x = snap(hit[0].point.x);
  const z = snap(hit[0].point.z);

  if (draggingFloor && buildMode === "floor") {
    createFloor(x, z);
  }

  if (draggingWall && buildMode === "wall") {
    lastWallGrid = { x, z };
    updateWallPreview(wallStart, lastWallGrid);
  }

  if (draggingFurniture && buildMode === "furniture" && draggedFurniture) {
    draggedFurniture.position.x = x + 0.5;
    draggedFurniture.position.z = z + 0.5;
    if (!draggedFurniture.userData) {
      draggedFurniture.userData = {};
    }
    draggedFurniture.userData.grid = { x, z };
  }
});

window.addEventListener("mouseup", e => {
  if (e.button === 0 && buildMode === "wall" && wallStart && lastWallGrid && draggingWall) {
    const start = wallStart;
    const end = lastWallGrid;
    const dx = end.x - start.x;
    const dz = end.z - start.z;

    if (dx !== 0 || dz !== 0) {
      if (Math.abs(dx) >= Math.abs(dz)) {
        const z = start.z;
        const from = Math.min(start.x, end.x);
        const to = Math.max(start.x, end.x);
        for (let i = from; i < to; i++) {
          createWall(i, z, "x");
        }
      } else {
        const x = start.x;
        const from = Math.min(start.z, end.z);
        const to = Math.max(start.z, end.z);
        for (let i = from; i < to; i++) {
          createWall(x, i, "z");
        }
      }
    }
  }

  draggingFloor = false;
  draggingWall = false;
  draggingFurniture = false;
  draggedFurniture = null;
  wallStart = null;
  lastWallGrid = null;
  clearWallPreview();
  controls.enabled = true;
});

function exportLayout() {
  const data = {
    floors: floors
      .map(f => f.userData && f.userData.grid)
      .filter(item => !!item),
    walls: walls
      .map(w => w.userData)
      .filter(item => !!item),
    furnitures: furnitures
      .map(f => {
        const d = f.userData;
        if (!d || !d.grid) return null;
        return {
          x: d.grid.x,
          z: d.grid.z,
          type: d.type || "bed",
          rotationY:
            typeof d.rotationY === "number" ? d.rotationY : (f.rotation && f.rotation.y) || 0
        };
      })
      .filter(item => !!item)
  };
  const json = JSON.stringify(data);
  if (navigator.clipboard && navigator.clipboard.writeText) {
    navigator.clipboard.writeText(json).then(() => {
      alert("布局JSON已复制到剪贴板");
    }).catch(() => {
      prompt("复制以下布局JSON：", json);
    });
  } else {
    prompt("复制以下布局JSON：", json);
  }
}

function importLayout() {
  const json = prompt("粘贴布局JSON：");
  if (!json) return;
  let data;
  try {
    data = JSON.parse(json);
  } catch (e) {
    alert("JSON 解析失败");
    return;
  }

  floors.forEach(f => {
    scene.remove(f);
  });
  walls.forEach(w => {
    scene.remove(w);
  });
  furnitures.forEach(f => {
    scene.remove(f);
  });
  floors.length = 0;
  walls.length = 0;
  furnitures.length = 0;

  if (data.floors) {
    data.floors.forEach(g => {
      if (g && typeof g.x === "number" && typeof g.z === "number") {
        createFloor(g.x, g.z);
      }
    });
  }

  if (data.walls) {
    data.walls.forEach(w => {
      if (w && typeof w.x === "number" && typeof w.z === "number" && w.dir) {
        createWall(w.x, w.z, w.dir);
      }
    });
  }

  if (data.furnitures) {
    data.furnitures.forEach(g => {
      if (g && typeof g.x === "number" && typeof g.z === "number") {
        createFurniture(
          g.x,
          g.z,
          g.type || "bed",
          typeof g.rotationY === "number" ? g.rotationY : 0
        );
      }
    });
  }
}

/* ================= 渲染 ================= */
function animate() {
  requestAnimationFrame(animate);
  const delta = clock.getDelta();

  if (gameMode === "live" && character) {
    const speed = 3;
    let dirX = 0;
    let dirZ = 0;
    if (moveForward) dirZ -= 1;
    if (moveBackward) dirZ += 1;
    if (moveLeft) dirX -= 1;
    if (moveRight) dirX += 1;

    let movedThisFrame = false;

    if (dirX !== 0 || dirZ !== 0) {
      const len = Math.hypot(dirX, dirZ) || 1;
      const ndx = dirX / len;
      const ndz = dirZ / len;
      const step = speed * delta;

      // 先嘗試在 X 軸方向移動
      if (ndx !== 0) {
        const targetX = character.position.x + ndx * step;
        const targetZ = character.position.z;
        if (canMoveCharacterTo(character.position.x, character.position.z, targetX, targetZ)) {
          character.position.x = targetX;
          character.position.z = targetZ;
          movedThisFrame = true;
        }
      }

      // 再嘗試在 Z 軸方向移動
      if (ndz !== 0) {
        const targetX = character.position.x;
        const targetZ = character.position.z + ndz * step;
        if (canMoveCharacterTo(character.position.x, character.position.z, targetX, targetZ)) {
          character.position.x = targetX;
          character.position.z = targetZ;
          movedThisFrame = true;
        }
      }

      if (movedThisFrame) {
        character.position.y = 0;
        updateCharacterRotationTowards(ndx, ndz, delta);
      }

      hasMoveTarget = false;
      pathCells = null;
      pathIndex = 0;
      if (moveMarker) moveMarker.visible = false;
    } else if (hasMoveTarget && pathCells && pathCells.length > 1) {
      const currentCell = pathCells[Math.min(pathIndex, pathCells.length - 1)];
      const targetX = currentCell.x + 0.5;
      const targetZ = currentCell.z + 0.5;
      const dx = targetX - character.position.x;
      const dz = targetZ - character.position.z;
      const dist = Math.hypot(dx, dz);

      if (dist > 0.05) {
        const step = speed * delta;
        const ratio = Math.min(1, step / dist);
        const moveX = dx * ratio;
        const moveZ = dz * ratio;
        const nx = character.position.x + moveX;
        const nz = character.position.z + moveZ;
        if (canMoveCharacterTo(character.position.x, character.position.z, nx, nz)) {
          character.position.x = nx;
          character.position.z = nz;
          character.position.y = 0;
          const dirNX = dx / (dist || 1);
          const dirNZ = dz / (dist || 1);
          updateCharacterRotationTowards(dirNX, dirNZ, delta);
          movedThisFrame = true;
        } else {
          hasMoveTarget = false;
          pathCells = null;
          pathIndex = 0;
          if (moveMarker) moveMarker.visible = false;
        }
      } else {
        pathIndex++;
        if (pathIndex >= pathCells.length) {
          character.position.x = targetX;
          character.position.z = targetZ;
          character.position.y = 0;
          hasMoveTarget = false;
          pathCells = null;
          pathIndex = 0;
          if (moveMarker) moveMarker.visible = false;
        }
      }
    }

    // 行走動畫：身體輕微上下起伏 + 手臂腿前後擺動
    const body = character.userData && character.userData.body;
    const head = character.userData && character.userData.head;
    const leftArm = character.userData && character.userData.leftArm;
    const rightArm = character.userData && character.userData.rightArm;
    const leftLeg = character.userData && character.userData.leftLeg;
    const rightLeg = character.userData && character.userData.rightLeg;
    if (movedThisFrame) {
      walkPhase += delta * 10;
    } else {
      walkPhase = Math.max(0, walkPhase - delta * 10);
    }

    const walkAmount = Math.sin(walkPhase) * 0.05;
    if (body) {
      body.position.y = 0.5 + walkAmount;
    }
    if (head) {
      head.position.y = 1.1 + walkAmount * 0.6;
    }

    const swing = Math.sin(walkPhase) * 0.4;
    const counterSwing = Math.cos(walkPhase) * 0.4;

    if (leftArm && rightArm) {
      leftArm.rotation.x = swing;
      rightArm.rotation.x = -swing;
    }

    if (leftLeg && rightLeg) {
      leftLeg.rotation.x = -counterSwing * 0.6;
      rightLeg.rotation.x = counterSwing * 0.6;
    }
  }

  controls.update();
  renderer.render(scene, camera);
}
animate();

window.addEventListener("resize", () => {
  camera.aspect = innerWidth / innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(innerWidth, innerHeight);
});
</script>
</body>
</html>
